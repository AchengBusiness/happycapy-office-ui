<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HappyCapy 的像素办公室</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        #game-container {
            border: 4px solid #fbbf24;
            border-radius: 8px;
            image-rendering: pixelated;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        #status-text {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 14px;
            background: rgba(0,0,0,0.8);
            padding: 12px 24px;
            border-radius: 8px;
            max-width: 90%;
            text-align: center;
            border: 2px solid #fbbf24;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="status-text">加载中...</div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <script src="/static/images.js"></script>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            pixelArt: true,
            physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
            scene: { preload: preload, create: create, update: update },
            loader: {
                crossOrigin: 'anonymous'
            }
        };

        const STATES = {
            idle: { name: '待命', area: 'breakroom' },
            writing: { name: '整理文档', area: 'workdesk' },
            researching: { name: '搜索信息', area: 'library' },
            executing: { name: '执行任务', area: 'server' },
            syncing: { name: '同步备份', area: 'library' },
            error: { name: '出错了', area: 'breakroom' }
        };

        const BUBBLE_TEXTS = {
            idle: ['享受生活~', 'Capy时间！', '放松一下', '泡个温泉吧'],
            writing: ['认真记录中', '这个重要', '整理思绪', '笔记很关键'],
            researching: ['查找资料', '发现新知识', '这个有趣', '深入研究中'],
            executing: ['全力以赴！', '马上完成', '效率max', '任务进行中'],
            syncing: ['备份数据', '安全第一', '云端同步', '保存进度'],
            error: ['哎呀...', '遇到问题了', '让我看看', '马上解决']
        };

        // 状态变量
        let gameInstance = null;
        let capy = null;
        let areas = {};
        let currentState = 'idle';
        let currentDetail = '';
        let statusText = null;
        let targetX = 150;
        let targetY = 500;

        // 气泡相关
        let bubble = null;
        let bubbleTimer = null;

        // 眨眼相关
        let blinkTimer = null;
        let isBlinking = false;

        // 打字机效果
        let typewriterText = '';
        let typewriterTarget = '';
        let typewriterIndex = 0;

        // 时间控制
        let lastFetch = 0;
        let lastBubble = 0;
        let lastTypewriter = 0;

        // 并发控制
        let isFetching = false;

        // 常量
        const FETCH_INTERVAL = 2000;
        const BLINK_INTERVAL = 2500;
        const BUBBLE_INTERVAL = 8000;
        const TYPEWRITER_DELAY = 50;

        // 纹理加载计数器
        let texturesLoaded = 0;
        const TOTAL_TEXTURES = 3;

        function preload() {
            const scene = this;

            // 监听纹理加载完成事件
            this.textures.on('addtexture', function(key) {
                texturesLoaded++;
                console.log('Loaded texture:', key, texturesLoaded + '/' + TOTAL_TEXTURES);
            });

            // 使用 base64 图片避免跨域问题
            this.textures.addBase64('office_bg', IMG_OFFICE_BG);
            this.textures.addBase64('capy_open', IMG_CAPY_OPEN);
            this.textures.addBase64('capy_closed', IMG_CAPY_CLOSED);
        }

        function create() {
            gameInstance = this;
            const scene = this;

            // 等待所有纹理加载完成后初始化场景
            function initScene() {
                scene.add.image(400, 300, 'office_bg');

                areas = {
                    workdesk: { x: 130, y: 235 },
                    breakroom: { x: 150, y: 500 },
                    meeting: { x: 420, y: 320 },
                    server: { x: 675, y: 220 },
                    library: { x: 680, y: 470 },
                    alert: { x: 150, y: 500 }
                };

                // 创建水豚角色
                capy = scene.physics.add.sprite(150, 500, 'capy_open');
                capy.setOrigin(0.5);
                capy.setScale(1.2);
                capy.setAlpha(1.0);
                capy.setDepth(50);

                // 牌匾
                const plaqueBg = scene.add.rectangle(400, 570, 420, 45, 0x8B4513);
                plaqueBg.setStrokeStyle(4, 0xfbbf24);
                plaqueBg.setDepth(80);
                const plaqueText = scene.add.text(400, 570, 'Happy Capy创业小窝', {
                    font: 'bold 18px monospace',
                    fill: '#fbbf24',
                    stroke: '#000',
                    strokeThickness: 3
                }).setOrigin(0.5).setDepth(81);

                statusText = document.getElementById('status-text');

                // 使用Phaser定时器进行眨眼（避免setTimeout泄漏）
                scene.time.addEvent({
                    delay: BLINK_INTERVAL,
                    callback: doBlink,
                    callbackScope: scene,
                    loop: true
                });

                // 初始获取状态
                fetchStatus();

                console.log('Scene initialized successfully');
            }

            // 检查纹理是否已全部加载
            if (texturesLoaded >= TOTAL_TEXTURES) {
                initScene();
            } else {
                // 等待纹理加载完成
                const checkInterval = scene.time.addEvent({
                    delay: 100,
                    callback: function() {
                        if (texturesLoaded >= TOTAL_TEXTURES) {
                            checkInterval.remove();
                            initScene();
                        }
                    },
                    loop: true
                });
            }
        }

        function update(time) {
            // 状态轮询（带并发控制）
            if (time - lastFetch > FETCH_INTERVAL && !isFetching) {
                fetchStatus();
                lastFetch = time;
            }

            // 定期气泡
            if (time - lastBubble > BUBBLE_INTERVAL) {
                showBubble(currentState === 'idle' ? null : currentDetail);
                lastBubble = time;
            }

            // 打字机效果
            if (typewriterIndex < typewriterTarget.length && time - lastTypewriter > TYPEWRITER_DELAY) {
                typewriterText += typewriterTarget[typewriterIndex];
                if (statusText) {
                    statusText.textContent = typewriterText;
                }
                typewriterIndex++;
                lastTypewriter = time;
            }

            // 移动水豚
            moveCapy(time);
        }

        function doBlink() {
            if (!capy || isBlinking) return;
            isBlinking = true;
            capy.setTexture('capy_closed');

            // 使用Phaser定时器恢复
            if (gameInstance) {
                gameInstance.time.delayedCall(150, () => {
                    if (capy) {
                        capy.setTexture('capy_open');
                    }
                    isBlinking = false;
                });
            }
        }

        function normalizeState(s) {
            if (!s) return 'idle';
            const stateMap = {
                'working': 'writing',
                'run': 'executing',
                'running': 'executing',
                'sync': 'syncing',
                'research': 'researching'
            };
            return stateMap[s] || s;
        }

        function fetchStatus() {
            if (isFetching) return;
            isFetching = true;

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);

            fetch('/status', { signal: controller.signal })
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    return response.json();
                })
                .then(data => {
                    clearTimeout(timeoutId);
                    const nextState = normalizeState(data.state);
                    const stateInfo = STATES[nextState] || STATES.idle;
                    const changed = nextState !== currentState;
                    const detailChanged = currentDetail !== (data.detail || '');

                    currentState = nextState;
                    currentDetail = data.detail || '';

                    if (changed || detailChanged) {
                        const nextLine = '[' + stateInfo.name + '] ' + currentDetail;
                        typewriterTarget = nextLine;
                        typewriterText = '';
                        typewriterIndex = 0;

                        const targetArea = areas[stateInfo.area] || areas.breakroom;
                        targetX = targetArea.x + (Math.random() - 0.5) * 40;
                        targetY = targetArea.y + (Math.random() - 0.5) * 40;

                        showBubble(currentDetail);
                    }
                })
                .catch(error => {
                    clearTimeout(timeoutId);
                    if (error.name !== 'AbortError') {
                        typewriterTarget = '连接失败，正在重试...';
                        typewriterText = '';
                        typewriterIndex = 0;
                    }
                })
                .finally(() => {
                    isFetching = false;
                });
        }

        function moveCapy(time) {
            if (!capy) return;

            const stateInfo = STATES[currentState] || STATES.idle;
            const baseTarget = areas[stateInfo.area] || areas.breakroom;

            // 偶尔随机微调目标位置
            if (Math.random() < 0.005) {
                targetX = baseTarget.x + (Math.random() - 0.5) * 40;
                targetY = baseTarget.y + (Math.random() - 0.5) * 40;
            }

            const dx = targetX - capy.x;
            const dy = targetY - capy.y;
            const speed = 1.0;

            if (Math.abs(dx) > 3) {
                capy.x += Math.sign(dx) * speed;
            }
            if (Math.abs(dy) > 3) {
                capy.y += Math.sign(dy) * speed;
            }

            // 移动时的摇摆效果
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                const wobble = Math.sin(time / 200) * 0.6;
                capy.y += wobble;
            }
        }

        function showBubble(customText) {
            // 清理旧气泡
            destroyBubble();

            if (!gameInstance || !capy) return;

            let text;
            if (customText && customText.length > 0) {
                text = customText.length > 20 ? customText.substring(0, 20) + '...' : customText;
            } else {
                const texts = BUBBLE_TEXTS[currentState] || BUBBLE_TEXTS.idle;
                text = texts[Math.floor(Math.random() * texts.length)];
            }

            const bubbleWidth = Math.max(text.length * 9 + 30, 80);
            const bubbleX = capy.x;
            const bubbleY = capy.y - 55;

            const bg = gameInstance.add.rectangle(bubbleX, bubbleY, bubbleWidth, 32, 0xffffff, 0.95);
            bg.setStrokeStyle(2, 0x2c3e50);

            const txt = gameInstance.add.text(bubbleX, bubbleY, text, {
                font: 'bold 11px monospace',
                fill: '#2c3e50',
                align: 'center'
            }).setOrigin(0.5);

            bubble = gameInstance.add.container(0, 0, [bg, txt]);
            bubble.setDepth(100);

            // 使用Phaser定时器自动销毁
            bubbleTimer = gameInstance.time.delayedCall(4000, destroyBubble);
        }

        function destroyBubble() {
            if (bubbleTimer) {
                bubbleTimer.remove();
                bubbleTimer = null;
            }
            if (bubble) {
                bubble.destroy();
                bubble = null;
            }
        }

        // 页面卸载时清理
        window.addEventListener('beforeunload', () => {
            destroyBubble();
        });

        new Phaser.Game(config);
    </script>
</body>
</html>
